import lief
import random
import os
import tempfile
import json
import subprocess
from xor_obfuscator import xor_obfuscate

COMMON_BENIGN_SECTIONS = os.listdir("section_list")
UPX_FILE_PATH = r"upx-5.0.0-win64\upx.exe"
XOR_OBFUSCATOR_PATH = r"xor_obfuscator.py"

def build_perturbed_exe(parsed_bytes):
    """Takes in perturbed EXE bytes and builds an EXE file out of it"""
    builder = lief.PE.Builder(parsed_bytes)
    builder.build()
    return bytes(builder.get_build())

"""Below functions implement the 7 Non Behavioural Change perturbations. Each function takes the raw bytes of the EXE file as a parameter"""

def overlay_append(exe_bytes):
    """Appends random bytes at the end of the EXE file"""
    append_byte_count = 2**random.randint(5,8)
    random_byte_range = random.randrange(128)
    perturbed_bytes = exe_bytes + bytes([random.randint(0, random_byte_range) for _ in range(append_byte_count)])
    parsed_perturbed_bytes = lief.parse(perturbed_bytes)
    return build_perturbed_exe(parsed_perturbed_bytes)

def dos_header(exe_bytes):
    """
    Modifies certain header fields in the EXE file
        initial_ip: The initial instruction pointer when the DOS stub executes.
        initial_relative_ss: The relative stack segment.
        overlay_number: Number of overlays in the executable.
        oem_id: Identifier for the OEM (Original Equipment Manufacturer).
        oem_info: Additional information about the OEM.
    """
    parsed_exe = lief.parse(exe_bytes)
    parsed_exe.dos_header.initial_ip = random.randint(0,8)
    parsed_exe.dos_header.initial_relative_ss = random.randint(0,8)
    parsed_exe.dos_header.overlay_number = random.randint(0,8)
    parsed_exe.dos_header.oem_id = random.randint(0,8)
    parsed_exe.dos_header.oem_info = random.randint(0,8) 
    return build_perturbed_exe(parsed_exe)

def dos_stub(exe_bytes):
    """
     This perturbation selects a random byte sequence within the DOS stub and replaces it with a randomly generated byte sequence.
     This process does not violate the PE file format,as the DOS stub is solely used to display an error message indicating that the executable is incompatible with DOS.
    """
    parsed_exe = lief.parse(exe_bytes)
    dos_stub_info = list(parsed_exe.dos_stub)
    sindex, eindex = sorted(random.sample(range(len(dos_stub_info)), 2))
    
    for i in range(sindex,eindex):
        dos_stub_info[i] = random.randrange(0,256)
    
    parsed_exe.dos_stub = dos_stub_info
    return build_perturbed_exe(parsed_exe)

def coff_header(exe_bytes):
    """
    This perturbation changes field values in the COFF header, such as timestamp field
    """
    parsed_exe = lief.parse(exe_bytes)
    parsed_exe.header.numberof_symbols = random.randrange(0,2**32)
    parsed_exe.header.time_date_stamps = random.randrange(0,2**32)
    parsed_exe.header.pointerto_symbol_table = random.randrange(0,2**32)
    return build_perturbed_exe(parsed_exe)

def optional_header(exe_bytes):
    """
    This perturbation changes field values in the Optional header, which does not affect the PE file format
    """
    parsed_exe = lief.parse(exe_bytes)
    parsed_exe.optional_header.dll_characteristics = random.randrange(0, 3000)
    return build_perturbed_exe(parsed_exe)

def data_directory(exe_bytes):
    """
    This perturbation randomly chooses a data in the data directory list and changes the values in the data, such as relative virtual address (rva) and size.
    """
    parsed_exe = lief.parse(exe_bytes)
    target_dir = random.choice(parsed_exe.data_directories)
    target_dir.rva = random.randrange(0,2**32)
    target_dir.size = random.randrange(0,2**32)
    return build_perturbed_exe(parsed_exe)

def rich_header(exe_bytes):
    """
    This perturbation inserts new content information to the Rich header. The content information includes id, build id, and count
    """
    parsed_exe = lief.parse(exe_bytes)
    new_entry = lief.PE.RichEntry()
    new_entry.id = 101
    new_entry.build_id = 0x766f
    new_entry.count = 2
    parsed_exe.rich_header.add_entry(new_entry)
    return build_perturbed_exe(parsed_exe)

"""Below functions implement the 7 Behavioural Change perturbations. Each function takes the raw bytes of the EXE file as a parameter"""

def section_rename(exe_bytes):
    """
    This perturbation changes the name of a randomly selected section in PE sections to a random string. For example, it changes the section named .data to .<random-string>
    """
    length = random.randrange(1,6)
    parsed_exe = lief.parse(exe_bytes)
    name = "." + ''.join(random.sample([chr(i) for i in range(97,123)], length))
    targeted_section = random.choice(parsed_exe.sections)
    targeted_section.name = name
    return build_perturbed_exe(parsed_exe)

def section_add(exe_bytes):
    """
    Extract some sections from benign programs, which are then added to a malware variant sample in order to camouflage a target malware sample's (statistical) characteristics with added binary code (i.e., making it indistinguishable from benign programs).
    """
    parsed_exe = lief.parse(exe_bytes)
    length = random.randrange(1,6)  # Length of the name of the new section
    # Create a random section name of given length
    new_section = lief.PE.Section("." + "".join(random.sample([chr(i) for i in range(97,123)],length)))  

    # Define random parameters
    upper = random.randrange(128)
    new_section_size = 2 ** random.randint(5, 8)
    size = parsed_exe.optional_header.section_alignment
    
    section_filename = random.choice(COMMON_BENIGN_SECTIONS)
    with open(f"section_list/{section_filename}", "r") as file:
        section_data = json.load(file)

    new_section.content = section_data[:new_section_size]
    new_section.virtual_size = size
    new_section.virtual_address = max([s.virtual_address + s.virtual_size for s in parsed_exe.sections])
    
    # Adds the newly created section to the PE file. Randomly assigns a section type from predefined categories (e.g., .text, .data, .bss, etc.).

    parsed_exe.add_section(new_section, random.choice([
        lief.PE.SECTION_TYPES.BSS,
        lief.PE.SECTION_TYPES.DATA,
        lief.PE.SECTION_TYPES.EXPORT,
        lief.PE.SECTION_TYPES.IDATA,
        lief.PE.SECTION_TYPES.RELOCATION,
        lief.PE.SECTION_TYPES.RESOURCE,
        lief.PE.SECTION_TYPES.TEXT,
        lief.PE.SECTION_TYPES.TLS_,
        lief.PE.SECTION_TYPES.UNKNOWN,
    ]))
    
    return build_perturbed_exe(parsed_exe)

def section_append(exe_bytes):
    """
    This perturbation appends some random byte sequence to the end of a section if the length of the content is smaller than the allocated size.
    """
    parsed_exe = lief.parse(exe_bytes)
    targeted_section = random.choice(parsed_exe.sections)
    available_size = targeted_section.size - len(targeted_section.content)
    new_section_size = 2**random.randint(5,8)
    
    # If the virtual size is less than or equal to the physical size, set virtual_size = size.
    # Otherwise, increase the sectionâ€™s size to the next 512-byte boundary
    if targeted_section.virtual_size <= targeted_section.size:
        targeted_section.virtual_size = targeted_section.size
    else:
        targeted_section.size = (int(targeted_section.virtual_size/512)+1)*512
    
    # Ensures that the new random data does not exceed the available space.
    if new_section_size > available_size:
        new_section_size = available_size
    
    # Inject remaining available space in the section content wwith random data.
    upper_bound = random.randrange(128)
    temp = list(targeted_section.content)
    temp = temp + [random.randint(0, upper_bound) for _ in range(new_section_size)]
    targeted_section.content = temp
    return build_perturbed_exe(parsed_exe)

def code_cave_inject(exe_bytes):
    """
    This perturbation injects some random byte sequence into the code cave, which is unused byte sequences in a PE file. It usually exists between each section and header
    """
    def last_used_index(bytelist):
        for i in range(len(bytelist)-1,0,-1):
            if bytelist[i] != 0:
                return i+1
        return -1
    
    parsed_exe = lief.parse(exe_bytes)
    
    # Randomly selects a section from the PE file and ensures that the selected section is not empty (has some content).
    while True:
        target_section = random.choice(parsed_exe.sections)
        if len(target_section.content) != 0:
            break

    start_index = last_used_index(target_section.content)
    content = list(target_section.content)
    content_len = len(content)

    # Injects 10 random bytes. Ensure modification does not exceed section limits
    for i in range(start_index+10, start_index+20):
        if i >= content_len:
            break
        content[i] = random.randrange(0,256)
    target_section.content = content

    return build_perturbed_exe(parsed_exe)
    
def upx_pack(exe_bytes):
    """
    This perturbation packs the PE file with the UPX tool. Options for executing the UPX tool are randomy selected, such as compression level
    """
    exe_bytes_copy = exe_bytes
    # Check if UPX.exe exists
    if not os.path.exists(UPX_FILE_PATH):
        raise FileNotFoundError(f"UPX Packer not found at {UPX_FILE_PATH}")
    
    # Create a temporary exe file upon which UPX packer will operate
    with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as tmpfile:
        tmp_filename = tmpfile.name
        tmpfile.write(exe_bytes)
        
    packed_filename = tmp_filename.replace(".exe", "_packed.exe")
    
    options = ['--force', '--overlay=copy']
    options += ['-{}'.format(random.randint(1, 9))]
    options += ['--compress-exports={}'.format(random.randint(0, 1))]
    options += ['--compress-icons={}'.format(random.randint(0, 3))]
    options += ['--compress-resources={}'.format(random.randint(0, 1))]
    options += ['--strip-relocs={}'.format(random.randint(0, 1))]
    
    # Run UPX with randomized options
    with open(os.devnull, 'w') as DEVNULL:
        retcode = subprocess.call(
            [UPX_FILE_PATH] + options + [tmp_filename, '-o', packed_filename],
            stdout=DEVNULL, stderr=DEVNULL)
        
    # Read the packed file if UPX was successful
    if retcode == 0 and os.path.exists(packed_filename):
        with open(packed_filename, 'rb') as infile:
            output_bytes = infile.read()
        os.unlink(packed_filename)  # Remove the packed file
    else:
        output_bytes = exe_bytes_copy   # If Packing was unsuccessful
        
    os.unlink(tmp_filename)     # Remove temporary file
    parsed_exe = lief.parse(output_bytes)
    return build_perturbed_exe(parsed_exe)

def upx_unpack(exe_bytes):
    """
    This perturbation unpacks the packed EXE file with the UPX tool
    """
    exe_bytes_copy = exe_bytes
    
    # Check if UPX.exe exists
    if not os.path.exists(UPX_FILE_PATH):
        raise FileNotFoundError(f"UPX Packer not found at {UPX_FILE_PATH}")
    
    # Create a temporary file for the packed executable
    with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as tmpfile:
        tmp_filename = tmpfile.name
        tmpfile.write(exe_bytes)
        
    unpacked_filename = tmp_filename.replace(".exe", "_unpacked.exe")

    # Run UPX to unpack the file
    with open(os.devnull, 'w') as DEVNULL:
        retcode = subprocess.call(
            [UPX_FILE_PATH, tmp_filename, '-d', '-o', unpacked_filename],
            stdout=DEVNULL, stderr=DEVNULL
        )

    os.unlink(tmp_filename)  # Delete the original packed file

    # If unpacking was successful, read and return the unpacked bytes
    if retcode == 0 and os.path.exists(unpacked_filename):
        with open(unpacked_filename, 'rb') as result:
            output_bytes = result.read()
        os.unlink(unpacked_filename)  # Delete the unpacked file
    else:
        output_bytes = exe_bytes_copy  # Return original bytes if UPX failed

    parsed_exe = lief.parse(output_bytes)
    return build_perturbed_exe(parsed_exe)

def xor_obfuscation(exe_bytes):
    """
    This perturbation is a popular technique for generating real world malware samples. It simply encrypts some binary code using XOR operation with random key bytes, and the encrypted file then decrypts itself and executes during the runtime.
    """
    # Check if xor_obfuscator.py exists
    if not os.path.exists(XOR_OBFUSCATOR_PATH):
        raise FileNotFoundError(f"XOR Obfuscator not found at {XOR_OBFUSCATOR_PATH}")
    
    with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as tmpfile:
        tmp_filename = tmpfile.name
        tmpfile.write(exe_bytes)
        
    # Send the input EXE to XOR obfuscator and store obfuscated EXE as obfuscated.exe
    xor_obfuscate(tmp_filename, "obfuscated.exe")
    
    os.unlink(tmp_filename)
    # Read the obfuscated EXE bytes
    with open("obfuscated.exe", "rb") as f:
        obfuscated_bytes = f.read()
    # Cleanup temporary files
    os.remove("obfuscated.exe")
    os.remove("stub.c")  # Remove the generated C stub
    
    parsed_exe = lief.parse(obfuscated_bytes)
    return build_perturbed_exe(parsed_exe)